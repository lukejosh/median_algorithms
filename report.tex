\documentclass{article}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{apacite}
\usepackage{svg}
\usepackage{placeins}
\usepackage{float}
\usepackage[margin=1in]{geometry}
\usepackage{lipsum}

\title{CAB302 - Assignment 2}
\author{Luke Josh, Jason Queen}
\begin{document}

\bibliographystyle{apacite}
\maketitle
\tableofcontents

\section{Summary}
    The purpose of this report is to analyse algorithms yada yada average complexity yada yada c++ yada yada execution time yada yada.

\section{Description of the Algorithms}
    \subsection{Brute Force}
        The brute force median algorithm works by manually checking each value of the array, and seeing if it's position in a sorted array is in the median position of $|k / 2|$. It does this by checking each element of the array against every other element of the array, and counting the number of elements that are less than the value, and the number of elements that are greater than the value.

        Recalling that the median value of a list of numbers is the one that were to occur in centre value (rounded up for this purpose), we can test if a value is the median value by seeing if it has half the arrays values smaller than it. This can be seen in the psuedocode included in the next section

        \subsubsection{The Algorithm}
            \begin{algorithm}[H]
                \caption{Brute Force Median}
                \begin{algorithmic}[1]
                    \Function{BruteForceMedian}{$A[0..n - 1]$}
                        \State{$k \leftarrow \|n / 2\|$}
                        \For{$i \leftarrow 1$ \bf{to} $n - 1$}
                            \State{$numsmaller \leftarrow 0$}
                            \State{$numeqal \leftarrow 0$}
                            \For{$j \leftarrow 0$ \bf{to} $n - 1$}
                                \If{$A[j] < A[i]$}
                                    \State{$numsmaller \leftarrow numsmaller + 1$}
                                \Else
                                    \If{$A[j] = A[i]$}
                                        \State{$numequal \leftarrow numequal + 1$}
                                    \EndIf
                                \EndIf
                            \EndFor
                            \If{$numsmaller < k$ \bf{and} $k \leq (numsmaller + numequal)$}
                                \State{\bf{return} $A[i]$}
                            \EndIf
                        \EndFor
                    \EndFunction
                \end{algorithmic}
            \end{algorithm}

    \subsection{Median Selection Algorithm}
        The selection algorithm for finding the median value of the array borrows much of it's logic from the Quicksort algorithm. The algoritm works by partitioning the array into subarrays, searching for the median value stage by stage, sorting as it goes. 

        First, the index of the median value is determined - being half the length of the array, here being rounded up. If the array is of length one, this is treated as a special case, and the value is simply returned, otherwise, it begins to partition.\\

        It begins by finding the index of the first element in the array (hereby reffered to as the primary element), if the array were to be sorted. It loops through each value other than the primary value (hereby reffered to as the secondary element), and checks to see whether the secondary value is less than the primary value. If a secondary value is less than a primary value, the secondary value is swapped with the element in front of the primary element (or the next unswapped value after the primary value, if multiple values are found). At the conclusion of the loop, the primary value is swapped with the value in the position that the last secondary element that was swapped. It should be noted that there is no gaurentee that the array will be sorted by this process - it is just ensuring that all values to the left of the first element are lesser, and all values to the right are greater. An example of this process is as follows, on an array $A = [3 5 4 2 1]$:\\

        \noindent$A = [3 5 4 2 1]$ 5 and 4 are both greater than 3, do nothing\\\\
        $A = [3 2 4 5 1]$ $2 < 3$, swap 5 with 2\\\\
        $A = [3 2 1 5 4]$ $1 < 3$, swap 4 with 1\\\\
        $A = [1 2 3 5 4]$ Finally, swap 3 with 1\\

        If the first value happens to be the median value of the array, the algorithm stops. However, if the index returned is not the median index, there are two possibilites:

        \begin{enumerate}
            \item If the index is less than the median index, the same process as above is performed, ignoring the first element of the array.
            \item If the index is greater than the median index, the same process as above is performed, ignoring the last element of the array.

        \end{enumerate}

        This process continues until the value with an index equal to the median index is found

        \subsubsection{The Algorithm}
            \begin{algorithm}[H]
                \caption{Selecion Median}
                \begin{algorithmic}[1]
                    \Function{Median}{$A[0..n - 1$}
                        \If{$n = 1$}
                            \State{\bf{return} $A[0]$}
                        \Else
                            \State{Select($A, 0, |n/2|, n - 1$)}
                        \EndIf
                    \EndFunction\\

                    \Function{Select}{$A[0..n - 1], l, m, h$}
                        \State{$pos \leftarrow$ Partition($A, l, h$)}
                        \If{$pos = m$}
                            \State{\bf{return} $A[pos]$}
                        \EndIf
                        \If{$pos > m$}
                            \State{\bf{return} Select($A, l, m, pos - 1$)}
                        \EndIf
                        \If{$pos < m$}
                            \State{\bf{return} Select($A, pos + 1, m, h$)}
                        \EndIf
                    \EndFunction\\

                    \Function{Partition}{$A[0..n - 1], l, h$}
                        \State{$pivotval \leftarrow A[l]$}
                        \State{$pivotloc \leftarrow l$}

                        \For{$j \leftarrow l + 1$ \bf{to} $h$}
                            \If{$A[j] < pivotval$}
                                \State{$pivotloc \leftarrow pivotloc + 1$}
                                \State{swap($A[pivotloc], A[j]$)}
                            \EndIf
                            \State{swap($A[l], A[pivotloc]$)}
                        \EndFor
                    \State{\bf{return} $pivotloc$}
                    \EndFunction
                \end{algorithmic}
            \end{algorithm}


\section{Theoretical Analysis of the Algorithms}
    \subsection{Brute Force Median}
        \subsubsection{Choice of Basic Operations}
            The operation that best defines the complexity and running time of the brute force median algorithm is the comparison $A[j] < A[i]$. This comparison operation is performed more than any other operation in the algorithm - a minimum of $n - 1$ times, and a maximum of $(n - 1)^2$ times.
        \subsubsection{Choice of Problem Size}
            Words
        \subsubsection{Average Case Efficiency}
            The average case efficiency of the algorithm can be derived by considering then number of operations required to determine the median of an arbitrarily sized array. Consider an array $A = [a_1, a_2, ..., a_n]$ with it's median value placed at position $k$. The algorithm must check each element in the array up to and including $A[k]$ against each element in the array, including itself. Thus, the algorithm must perform $k \cdot n$ comparisons to determine that $A[k]$ is the median value of the array.

            To determine the average number of operations for an array of size $n$, we must consider the pairity of the size of the array, as the algorithm chooses the value to the left of the midpoint when there are an even number of elements. We will first assume that each value in the array has an equivalent chance of being the median. In this case, the average case number of operations to determine the median is average number of operations for each $M = A[k]$ $\forall k \in [0, 1, ..., n]$:

            \begin{align}
                & c_{average} = \frac{\sum_{j = 1}^{n} j \cdot n}{n} \\
                & c_{average} = \sum_{j = 1}^n j\\
                & c_{average} = \frac{n^2 + n}{2}
            \end{align}

            To account for the issue of pairty, consider two sorted arrays, $A = [a_1, a_2, ..., a_n]$ and $B = [a_1, a_2, ..., a_{n+1}$, where $n$ is odd. In each of these arrays, the median value will be the same, $M = a_{floor(\frac{n}{2})}$, and will have to check the same number of elements to find it, however, in $B$, each element is checked against $n + 1$ other elements, as opposed to A's $n$ other elements. We can use this to restate the above value for the average number of comparisons as $c_{odd average} = \frac{n^2 + n}{2}$, and conversely, $c_{even average} = \frac{n^2}{2}$. These two statements can be combined using a modulo operator to give the true average number of comparisons for an arbitrarily sized array as:
            \begin{align}
                c_{average} = \frac{n^2 + (n\mod 2) \cdot n}{2}
            \end{align}
            Which gives the algorithm an average case complexity of $\Theta(n^2)$.
    \subsection{Selection Median}
        \subsubsection{Choice of Basic Operations}
            Words
        \subsubsection{Choice of Problem Size}
            Words
        \subsubsection{Average Case Efficiency}
            Words

\section{Methodology, Tools and Techniques}
    \subsection{Programming Environment}
    \subsection{Implementation of the Algorithms}
    \subsection{Generating Test Data and Running the Experiments}

\section{Experimental Results}
    \subsection{Functional Testing}
    \subsection{Average-Case Number of Basic Operations for an Item in the Set}
    \subsection{Average-Case Number of Basic Operations for an Item not in the Set}
    \subsection{Average-Case Execution Time for an Item in the Set}
    \subsection{Average-Case Execution Time for an Item not in the Set}

\end{document}