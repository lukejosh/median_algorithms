\documentclass{article}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{apacite}
\usepackage{svg}
\usepackage{placeins}
\usepackage{float}
\usepackage[margin=1in]{geometry}
\usepackage{lipsum}
\usepackage{textcomp}
\usepackage{graphicx}

\graphicspath{{./Images/}}

\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\definecolor{darkgreen}{rgb}{0.0, 0.2, 0.13}
\lstset{
backgroundcolor=\color{lbcolor},
    tabsize=4,    
%   rulecolor=,
    language=[GNU]C++,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=false,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        numbers=left,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.026,0.112,0.095},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
        numberstyle=\color[rgb]{0.205, 0.142, 0.73},
%        \lstdefinestyle{C++}{language=C++,style=numbers}â€™.
}
\lstset{
    backgroundcolor=\color{lbcolor},
    tabsize=4,
  language=C++,
  captionpos=b,
  tabsize=3,
  frame=lines,
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  breaklines=true,
  showstringspaces=false,
  basicstyle=\footnotesize,
%  identifierstyle=\color{magenta},
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color{darkgreen},
  stringstyle=\color{red}
  }

\title{CAB302 - Assignment 2}
\author{Luke Josh, Jason Queen}
\begin{document}

\bibliographystyle{apacite}
\maketitle
\tableofcontents

\section{Summary}
    The purpose of this report is to analyse and compare the average complexity of the selection median algorithm against a brute force solution. This report uses algorithm analysis techniques to experimentally determine the average case efficiency of both the selection median and brute force median algorithm. The expected theoretical efficiencies of the algorithms are evaluated using mathematical analysis and are contrasted against the computed experimental results. The results for each algorithm are also compared to each other and the most efficient algorithm is determined.

\section{Description of the Algorithms}
    \subsection{Brute Force}
        The brute force median algorithm works by manually checking each value of the array and determining if the element's position in a sorted array is in the median position of $\frac{n}{2}$. It does this by checking each element of the array against every other element of the array, and counting the number of elements that are less than the value, and the number of elements that are greater than the value.

        Recalling that the median value of a list of numbers is the element that occurs in center position (rounded up for the purpose of this algorithm), the algorithm tests if a value is the median value by testing if half the elements in the array are less than the value. This can be seen in the pseudocode included in the next section.

        \subsubsection{The Algorithm}
            \begin{algorithm}[H]
                \caption{Brute Force Median}
                \begin{algorithmic}[1]
                    \Function{BruteForceMedian}{$A[0..n - 1]$}
                        \State{$k \leftarrow \|n / 2\|$}
                        \For{$i \leftarrow 1$ \bf{to} $n - 1$}
                            \State{$numsmaller \leftarrow 0$}
                            \State{$numeqal \leftarrow 0$}
                            \For{$j \leftarrow 0$ \bf{to} $n - 1$}
                                \If{$A[j] < A[i]$}
                                    \State{$numsmaller \leftarrow numsmaller + 1$}
                                \Else
                                    \If{$A[j] = A[i]$}
                                        \State{$numequal \leftarrow numequal + 1$}
                                    \EndIf
                                \EndIf
                            \EndFor
                            \If{$numsmaller < k$ \bf{and} $k \leq (numsmaller + numequal)$}
                                \State{\bf{return} $A[i]$}
                            \EndIf
                        \EndFor
                    \EndFunction
                \end{algorithmic}
            \end{algorithm}

    \subsection{Median Selection Algorithm}
        The selection algorithm for finding the median value of the array derives much of its logic from the Quicksort algorithm. The selection algorithm uses a recursive method to determine the median of the array.  The recursive function first performs a partition on the array where all elements less than a pivot element (starting with element 0 as the first pivot) are swapped until the pivot element swapped into its correct position. All elements with an index lower than that of the pivot, now also have a value which is less than that of the pivot. If the new position of the pivot is the middle of the array then the value of the pivot is returned as it is the median of the array. This check is the base case of the recursive function.
        Otherwise, if the position of the pivot is less than or greater than that of the middle index then the recursive function is called again and then performs the partition on either the lower or upper partition of the array respectively. This is performed until the base case is met and the element in the middle of the array is returned.\\
        It should be noted that there is no guarantee that the whole array will be completely sorted by this process. However, all elements at a lower index than that of the pivot will have a value that is lower than that of the pivot element and all elements with an index greater than that of the pivot element will have values that are also greater than the value of the median.
        Furthermore, in contract to the brute force algorithm, when this algorithm is performed on an even array size, returns the value which is towards the lower section of the sorted array.
        An example of this process is as follows, on an array $A = [3, 5, 4, 2, 1]$:\\

        \noindent$A = [3, 5, 4, 2, 1] \rightarrow$  5 and 4 are both greater than 3, do nothing\\\\
        $A = [3, 2, 4, 5, 1] \rightarrow$  $2 < 3$, swap 5 with 2\\\\
        $A = [3, 2, 1, 5, 4] \rightarrow$  $1 < 3$, swap 4 with 1\\\\
        $A = [1, 2, 3, 5, 4] \rightarrow$  Finally, swap 3 with 1\\

        If the first value happens to be the median value of the array, the algorithm stops. However, if the index returned is not the median index, there are two possibilites:

        \begin{enumerate}
            \item If the index is less than the median index, the same process as above is performed, ignoring the first element of the array.
            \item If the index is greater than the median index, the same process as above is performed, ignoring the last element of the array.
        \end{enumerate}

        This process continues until the value with an index equal to the median index is found.

        \subsubsection{The Algorithm}
            \begin{algorithm}[H]
                \caption{Selecion Median}
                \begin{algorithmic}[1]
                    \Function{Median}{$A[0..n - 1$}
                        \If{$n = 1$}
                            \State{\bf{return} $A[0]$}
                        \Else
                            \State{Select($A, 0, |n/2|, n - 1$)}
                        \EndIf
                    \EndFunction\\

                    \Function{Select}{$A[0..n - 1], l, m, h$}
                        \State{$pos \leftarrow$ Partition($A, l, h$)}
                        \If{$pos = m$}
                            \State{\bf{return} $A[pos]$}
                        \EndIf
                        \If{$pos > m$}
                            \State{\bf{return} Select($A, l, m, pos - 1$)}
                        \EndIf
                        \If{$pos < m$}
                            \State{\bf{return} Select($A, pos + 1, m, h$)}
                        \EndIf
                    \EndFunction\\

                    \Function{Partition}{$A[0..n - 1], l, h$}
                        \State{$pivotval \leftarrow A[l]$}
                        \State{$pivotloc \leftarrow l$}

                        \For{$j \leftarrow l + 1$ \bf{to} $h$}
                            \If{$A[j] < pivotval$}
                                \State{$pivotloc \leftarrow pivotloc + 1$}
                                \State{swap($A[pivotloc], A[j]$)}
                            \EndIf
                            \State{swap($A[l], A[pivotloc]$)}
                        \EndFor
                    \State{\bf{return} $pivotloc$}
                    \EndFunction
                \end{algorithmic}
            \end{algorithm}


\section{Theoretical Analysis of the Algorithms}
    \subsection{Choice of Problem Size}
        The algorithms are tested using randomly generated arrays of sizes 1 through to 999 in steps of 3. Additionally, the test for each array size is repeated 2000 times in order to normalize the results.

        The upper limit was chosen as array sizes greater than 1000 have brute force time complexities which are significantly large. This limits the number of averages that can be taken for each array size as the total time to run all tests increases to a value that is impractical to perform repeatedly. 

        The odd step size of 3 is chosen so that tests are performed for both odd and even array sizes. 
    \subsection{Brute Force Median}
        \subsubsection{Choice of Basic Operations}
            The operation that best defines the complexity and running time of the brute force median algorithm is the comparison $A[j] < A[i]$. This comparison operation is performed more than any other operation in the algorithm - a minimum of $n - 1$ times, and a maximum of $(n - 1)^2$ times.

        \subsubsection{Average Case Efficiency}
            The average case efficiency of the algorithm can be derived by considering then number of operations required to determine the median of an arbitrarily sized array. Consider an array $A = [a_1, a_2, ..., a_n]$ with it's median value placed at position $k$. The algorithm must check each element in the array up to and including $A[k]$ against each element in the array, including itself. Thus, the algorithm must perform $k \cdot n$ comparisons to determine that $A[k]$ is the median value of the array.

            To determine the average number of operations for an array of size $n$, we must consider the pairity of the size of the array, as the algorithm chooses the value to the left of the midpoint when there are an even number of elements. We will first assume that each value in the array has an equivalent chance of being the median. In this case, the average case number of operations to determine the median is average number of operations for each $M = A[k]$ $\forall k \in [0, 1, ..., n]$:

            \begin{align}
                & c_{average} = \frac{\sum_{j = 1}^{n} j \cdot n}{n} \\
                & c_{average} = \sum_{j = 1}^n j\\
                & c_{average} = \frac{n^2 + n}{2}
            \end{align}

            To account for the issue of pairty, consider two sorted arrays, $A = [a_1, a_2, ..., a_n]$ and $B = [a_1, a_2, ..., a_{n+1}$, where $n$ is odd. In each of these arrays, the median value will be the same, $M = a_{floor(\frac{n}{2})}$, and will have to check the same number of elements to find it, however, in $B$, each element is checked against $n + 1$ other elements, as opposed to A's $n$ other elements. We can use this to restate the above value for the average number of comparisons as $c_{odd average} = \frac{n^2 + n}{2}$, and conversely, $c_{even average} = \frac{n^2}{2}$. These two statements can be combined using a modulo operator to give the true average number of comparisons for an arbitrarily sized array as:
            \begin{align}
                c_{average} = \frac{n^2 + (n\mod 2) \cdot n}{2}
            \end{align}
            Which gives the algorithm an average case complexity of $\Theta(n^2)$.

            The above caluculations are assuming the median value for the array only occurs once. In other cases, an array may take the form $[1, 2, 3, 3, 3, 4, 5]$, which will skew the results for the average number of comparisons. For example, an array $A = [1, 2, 4, 5, 3, 3, 3]$, the median value is 3, but 3 appears more than once. This means the algorithm will find the median at the 5th position, but it must check each value against 7 other values.

    \subsection{Selection Median}
        \subsubsection{Choice of Basic Operations}
            The operation that best defines the complexity and running time of the selection median algorithm is the comparison $A[j] < pivotval$ which is performed by the partition sort logic borrowed from the Quicksort algorithm. This comparison operation is performed more than any other operation in the algorithm - a minimum of $n - 1$ times if the median value is in the first position of the array, and a maximum of $(n - 1)^2$ times, if the median value is in it's correct position at the centre of the array.

        \subsubsection{Average Case Efficiency}
            Some dickhead online quotes fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you fuck you.

\section{Methodology, Tools and Techniques}
    \subsection{Programming Environment}
        All testing and computation was executed on a Microsoft Surface running Windows 8.1 64 bit, Intel Core i5 Processor (1.9GHz), 4GB DDR4 RAM.
        \subsection{Implementation of the Algorithms}
        The algorithms and their tests were both implemented in C++, compiled using the GCC GNU Compiler in the Code Blocks IDE. The source code for these algorithms is included in Appendix 1.

        In general, operation counts were performed by running the algorithm a large number of times on randomly generated arrays, appending the number of operations for each iteration to a pointer to a integer running total, and then calculating the average. The computation time for algorithms was generated in much the same way - using clock types to find the time between two points in the code (namely, the start and end of the algorithm), and then repeating it and taking the average.
    \subsection{Generating Test Data and Running the Experiments}
        I think I've already covered this, read again when you're not tired
 
\section{Experimental Results}
    All graphs referenced in this section have been included in section 2 of the appendix.
    \subsection{Functional Testing}
        To ensure the functional correctness of the implemented algorithms - a number of unit tests have been implemented. These tests are included the the test.cpp file, which is also included in appendix 1 (section 6.1.1). These unit tests ensure that the algorithms produce the expected results for a number of predefined test cases.
    \subsection{Brute Force}
        \subsubsection{Number of operations}
            The number of operations of the brute force median algorithm was calculated by running the algorithm on a random array of various sizes, and counting the number of times the comparison $A[j] < A[i]$ is performed. This expected number of comparisons was calculated above to be $\frac{n^2}{2}$ for odd sized arrays, and $\frac{n^2 + n}{2}$ for even sized arrays. This function has been graphed along the data that was collected from the tests - and clearly shows that the expected trend holds true.

            It must be noted that the data sets used to test the number of operations is not tested for uniqueness - a single value may appear more than once. This causes some amount of discrepency between the expected result and the actual result, but can mostly be corrected by increasing the maximum value a value can take. This can be seen in the source code in section 6.1.4, on line 97.
        \subsubsection{Computation time}
            The computation for the brute force algorithm was expected to run in $\Theta{n^2}$ time. In other words, the time for the algorithm to run is determined quadratically by the number of elements in the array. It can be seen in the included figure that the collected data follows a quadratic trend. Included on this graph also is the operation count again, which allows us to see that the average case running time is indeed correllated to the number of basic operations performed.
    \subsection{Selection}
        \subsubsection{Number of operations}
            The selection algorithm was calculated to perform [a number of operations that it doesn't actually perform], which clearly [cannot be seen because it's fucked].
        \subsubsection{Computation time}
            An operating complexity of $\Theta{n}$ was expected for the median selection. Looking at the graphs of the data collected, it is clear that there is a linear trend of computation time and size of the array. There is a large amount of variance [FOR SOME REASON].
    \subsection{Comparison}
        As the two algorithms perform the same operation, they are able to be quantitatively compared. In section 3, we have theoretically shown that the average computational complexity of the brute force and selection algorithms are $\Theta{n^2}$ and $\Theta{n}$ respectively. In section 5, we have shown that these theoretical models fit the data that was collected quite well - which allows us to confidently compare the two algorithms.

        It is clear that the selection algorithm is superiour to the brute force method for an arbitrarily sized array - shown computationality and [lol] analytically. Included in the figures are graphs comparing the computation time and operation count for both algorithms, these allow us to see the drastic difference between these two (result wise) equivalent algorithms. It can be seen that the difference in linear and quadratic running time causes the brute force method to reduce the selection method to less than a percent of the graphs y axis.

\section{Appendix}
    \subsection{Source Code}
        \subsubsection{Brute Force Median}
            \lstinputlisting{CAB301_Assignment2/bruteForceMedian.cpp}

        \subsubsection{Selection Median}
            \lstinputlisting{CAB301_Assignment2/selectionMedian.cpp}

        \subsubsection{Main}
            \lstinputlisting{CAB301_Assignment2/main.cpp}

        \subsubsection{Unit Tests}
            \lstinputlisting{CAB301_Assignment2/tests.cpp}
        \newpage


    \subsection{Figures}
        \subsubsection{Brute Force}
            \includegraphics[scale=0.6]{Images/brute_algorithm_basic_operations.png}\\
            \includegraphics[scale=0.6]{Images/brute_algorithm_time_taken.png}
        \subsubsection{Selection}
            \includegraphics[scale=0.6]{Images/selection_algorithm_basic_operations.png}\\
            \includegraphics[scale=0.6]{Images/selection_algorithm_time_taken.png}
        \subsubsection{Comparison}
            \includegraphics[scale=0.6]{Images/direct_comparison_basic_operations.png}\\
            \includegraphics[scale=0.6]{Images/direct_comparison_time_taken.png}
\end{document}