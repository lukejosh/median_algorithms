\documentclass{article}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{apacite}
\usepackage{svg}
\usepackage{placeins}
\usepackage{float}
\usepackage[margin=1in]{geometry}
\usepackage{lipsum}

\title{CAB302 - Assignment 2}
\author{Luke Josh, Jason Queen}
\begin{document}

\bibliographystyle{apacite}
\maketitle
\tableofcontents

\section{Summary}
    Lorem ipsum dolor sit amet, consectetur adipiscing elit. In et mauris felis. Etiam viverra molestie euismod. Nullam finibus nisl et mollis molestie. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Donec viverra lacinia ligula tristique convallis. Sed eget erat leo. Phasellus convallis blandit rhoncus. Donec tellus sapien, fringilla auctor purus sit amet, blandit mollis eros. Nulla arcu turpis, malesuada a odio mollis, sollicitudin varius elit. Vestibulum euismod dictum fermentum. Morbi consectetur bibendum quam, ac dictum velit hendrerit posuere. Etiam vel massa sit amet dui porta vehicula id ac diam.

\section{Description of the Algorithms}
    Duis scelerisque risus at urna efficitur, id laoreet dolor eleifend. Aenean sed nulla quis quam iaculis congue. Vivamus posuere dui in ornare posuere. Integer accumsan, diam ut pharetra vulputate, sapien neque consectetur nisl, in gravida neque lacus nec quam. Nullam sit amet pulvinar quam, sed tristique ante. Nunc eleifend orci non orci fringilla viverra quis eget libero. Pellentesque in metus non augue sodales tempor. Vivamus maximus malesuada ligula vel interdum. Nulla pretium lectus vel nisl faucibus, vitae pretium ante venenatis.
    \subsection{Brute Force}
        The brute force median algorithm works by manually checking each value of the array, and seeing if it's position in a sorted array is in the median position of $|k / 2|$
        \subsubsection{The Algorithm}
            \begin{algorithm}[H]
                \caption{Brute Force Median}
                \begin{algorithmic}[1]
                    \Function{BruteForceMedian}{$A[0..n - 1]$}
                        \State{$k \leftarrow \|n / 2\|$}
                        \For{$i \leftarrow 1$ \bf{to} $n - 1$}
                            \State{$numsmaller \leftarrow 0$}
                            \State{$numeqal \leftarrow 0$}
                            \For{$j \leftarrow 0$ \bf{to} $n - 1$}
                                \If{$A[j] < A[i]$}
                                    \State{$numsmaller \leftarrow numsmaller + 1$}
                                \Else
                                    \If{$A[j] = A[i]$}
                                        \State{$numequal \leftarrow numequal + 1$}
                                    \EndIf
                                \EndIf
                            \EndFor
                            \If{$numsmaller < k$ \bf{and} $k \leq (numsmaller + numequal)$}
                                \State{\bf{return} $A[i]$}
                            \EndIf
                        \EndFor
                    \EndFunction
                \end{algorithmic}
            \end{algorithm}

    \subsection{Johnsonbaugh and Schaeferâ€™s Algorithm}
        Words
        \subsubsection{The Algorithm}
            \begin{algorithm}[H]
                \caption{Selecion Median}
                \begin{algorithmic}[1]
                    \Function{Median}{$A[0..n - 1$}
                        \If{$n = 1$}
                            \State{\bf{return} $A[0]$}
                        \Else
                            \State{Select($A, 0, |n/2|, n - 1$)}
                        \EndIf
                    \EndFunction\\

                    \Function{Select}{$A[0..n - 1], l, m, h$}
                        \State{$pos \leftarrow$ Partition($A, l, h$)}
                        \If{$pos = m$}
                            \State{\bf{return} $A[pos]$}
                        \EndIf
                        \If{$pos > m$}
                            \State{\bf{return} Select($A, l, m, pos - 1$)}
                        \EndIf
                        \If{$pos < m$}
                            \State{\bf{return} Select($A, pos + 1, m, h$)}
                        \EndIf
                    \EndFunction\\

                    \Function{Partition}{$A[0..n - 1], l, h$}
                        \State{$pivotval \leftarrow A[l]$}
                        \State{$pivotloc \leftarrow l$}

                        \For{$j \leftarrow l + 1$ \bf{to} $h$}
                            \If{$A[j] < pivotval$}
                                \State{$pivotloc \leftarrow pivotloc + 1$}
                                \State{swap($A[pivotloc], A[j]$)}
                            \EndIf
                            \State{swap($A[l], A[pivotloc]$)}
                        \EndFor
                    \State{\bf{return} $pivotloc$}
                    \EndFunction
                \end{algorithmic}
            \end{algorithm}


\section{Theoretical Analysis of the Algorithms}
    \subsection{Brute Force Median}
        \subsubsection{Choice of Basic Operations}
            The operation that best defines the complexity and running time of the brute force median algorithm is the comparison $A[j] < A[i]$. This comparison operation is performed more than any other operation in the algorithm - a minimum of $n - 1$ times, and a maximum of $(n - 1)^2$ times.
        \subsubsection{Choice of Problem Size}
            Words
        \subsubsection{Average Case Efficiency}
            The average case efficiency of the algorithm can be derived by considering then number of operations required to determine the median of an arbitrarily sized array. Consider an array $A = [a_1, a_2, ..., a_n]$ with it's median value placed at position $k$. The algorithm must check each element in the array up to and including $A[k]$ against each element in the array, including itself. Thus, the algorithm must perform $k \cdot n$ comparisons to determine that $A[k]$ is the median value of the array.

            To determine the average number of operations for an array of size $n$, we must consider the pairity of the size of the array, as the algorithm chooses the value to the left of the midpoint when there are an even number of elements. We will first assume that each value in the array has an equivalent chance of being the median. In this case, the average case number of operations to determine the median is average number of operations for each $M = A[k]$ $\forall k \in [0, 1, ..., n]$:

            \begin{align}
                & c_{average} = \frac{\sum_{j = 1}^{n} j \cdot n}{n} \\
                & c_{average} = \sum_{j = 1}^n j\\
                & c_{average} = \frac{n^2 + n}{2}
            \end{align}

            To account for the issue of pairty, consider two sorted arrays, $A = [a_1, a_2, ..., a_n]$ and $B = [a_1, a_2, ..., a_{n+1}$, where $n$ is odd. In each of these arrays, the median value will be the same, $M = a_{floor(\frac{n}{2})}$, and will have to check the same number of elements to find it, however, in $B$, each element is checked against $n + 1$ other elements, as opposed to A's $n$ other elements. We can use this to restate the above value for the average number of comparisons as $c_{odd average} = \frac{n^2 + n}{2}$, and conversely, $c_{even average} = \frac{n^2}{2}$. These two statements can be combined to give the true average number of comparisons for an arbitrarily sized array as:
            \begin{align}
                c_{average} = \frac{n^2 + (n\mod 2) \cdot n}{2}
            \end{align}
            Which gives the algorithm an average case complexity of $\Theta(n^2)$.
    \subsection{Selection Median}
        \subsubsection{Choice of Basic Operations}
            Words
        \subsubsection{Choice of Problem Size}
            Words
        \subsubsection{Average Case Efficiency}
            Words

\section{Methodology, Tools and Techniques}
    \subsection{Programming Environment}
    \subsection{Implementation of the Algorithms}
    \subsection{Generating Test Data and Running the Experiments}

\section{Experimental Results}
    \subsection{Functional Testing}
    \subsection{Average-Case Number of Basic Operations for an Item in the Set}
    \subsection{Average-Case Number of Basic Operations for an Item not in the Set}
    \subsection{Average-Case Execution Time for an Item in the Set}
    \subsection{Average-Case Execution Time for an Item not in the Set}

\end{document}